### Part A: Cache 模拟器实现 (csim.c)

#### 1. 命令行参数解析 (Argument Parsing)

- **问题**：如何处理形如 `./csim -s 4 -E 1 ...` 的变长命令行参数。
- **解决方案**：使用 C 标准库函数 `getopt()`。
  - 利用 `switch-case` 结构配合 `optarg` 全局变量提取参数值。
  - 使用 `atoi()` 将字符串转换为整数。

#### 2. 动态内存管理 (Memory Management)

- **问题**：C 语言无法像 C++ `vector` 那样自动管理二维数组内存，且需模拟任意大小 ($S \times E$) 的 Cache。
- **解决方案**：使用多级指针 (`struct **`) 进行动态分配。
  - **分配 (Malloc)**：先分配 `S` 个组指针 (`cache = malloc(S * sizeof(ptr))`)，再在循环中为每个组分配 `E` 行 (`cache[i] = malloc(E * sizeof(struct))`)。
  - **释放 (Free)**：遵循“先子后父”原则，先遍历释放每一组的内存，最后释放首层指针，防止内存泄漏。

#### 3. 文件 I/O 与 格式化读取

- **问题**：读取 Trace 文件 (`.trace`) 时，需解析指令类型、地址和大小，并忽略指令加载 (`I`)。
- **纠错点**：`fopen` 的模式参数必须是字符串 `"r"` 而非字符 `'r'`，否则会导致段错误 (Segmentation Fault)。
- **解决方案**：使用 `fscanf(fp, " %c %lx,%d", ...)`。注意格式串中的空格，用于跳过每行末尾的换行符。

#### 4. LRU (Least Recently Used) 替换策略

- **问题**：当 Cache Set 满时，如何确定替换哪一行。
- **解决方案**：维护 `time_stamp` 字段。
  - **全局计时**：每处理一条有效操作，全局时间 `cur_time++`。
  - **更新机制**：命中 (Hit) 或 写入 (Fill) 时，更新当前行的 `time_stamp = cur_time`。
  - **替换机制**：遍历当前 Set，寻找 `time_stamp` 最小的行进行驱逐 (Eviction)。



# Part B: 矩阵转置优化实验笔记

## 0. 实验背景 (Context)

- **目标**：优化矩阵转置函数 $B = A^T$，最小化 Cache Miss。
- **Cache 参数**：$S=32$ (组), $E=1$ (路), $B=32$ (块大小)。
- **特性**：总容量 **1KB**，**直接映射 (Direct Mapped)**。这意味着每个内存地址只能映射到 Cache 中唯一固定的位置。

## 1. 核心挑战：两类不命中的博弈 (The Dual Challenges)

在直接映射 Cache 的限制下，我们需要同时解决两类 Miss：

### A. 容量不命中 (Capacity Miss) —— “装不下”

- **成因**：整个矩阵的工作集 (Working Set) 远大于 Cache 容量 (1KB)。若按行遍历大矩阵，头部数据在被重复使用前，就会被后续进来的冷数据挤出 Cache。
- **表现**：如果不进行**分块 (Blocking)**，Miss 率极高，根本无法利用 Cache 的时间局部性。
- **地位**：这是首先要解决的**基础问题**。
- 在直接映射 Cache 中，容量不命中的本质，就是工作集过大导致了无法避免的行间组索引冲突 。

### B. 冲突不命中 (Conflict Miss) —— “抢位置”

- **成因**：即使分块缩小了工作集，但由于 **直接映射 (E=1)** 的特性，若矩阵 A 和 B 的对应数据映射到同一个 Cache Set（例如 64x64 矩阵中每隔 4 行），它们会发生激烈的竞争。
- **表现**：出现**抖动 (Thrashing)**。即便 Cache 还有空闲 Set，数据也会因为“抢同一个坑位”而频繁 Miss。
- **地位**：这是 64x64 满分的瓶颈，也是本实验**最难优化的点**。

## 2. 通用解决方案 (Solutions)

| **痛点 (Miss 类型)** | **解决方案**                       | **原理**                                                     |
| -------------------- | ---------------------------------- | ------------------------------------------------------------ |
| **容量不命中**       | **分块技术 (Blocking)**            | **缩小工作集**。 将活跃区域限制在 Cache 能容纳的大小范围内 (如 8x8)，确保在处理当前块时，数据能一直留在 Cache 里。 |
| **冲突不命中**       | **寄存器缓冲 (Register Blocking)** | **消除映射冲突**。 利用 CPU 寄存器（局部变量）不占 Cache Set 的特性，作为 A 和 B 之间的“停火区”或“中转站”，打破 A 和 B 交替踢人的循环。 |

## 3. 针对不同尺寸的策略总结 (Strategies)

| **矩阵尺寸** | **关键限制分析**                                             | **解决方案策略**                                             | **期望 Miss** |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------- |
| **32x32**    | 矩阵一行 (128B) 占 4 个 Set。 Cache 总共能存 **8 行** 矩阵数据。 | **8x8 分块**。 8 行数据刚好填满 32 个 Set，无冲突。 利用 8 个局部变量一次性搬运一行 (A->Reg->B)。 | < 300         |
| **64x64**    | 矩阵一行 (256B) 占 8 个 Set。 Cache 只能存 **4 行** 矩阵数据。 每隔 4 行发生 Set 索引冲突。 | **8x8 外壳 + 4x4 内核**。 外层循环步长 8，内层逻辑将 8x8 拆解。 **关键技巧**：利用 B 的非冲突区域（如右上角）作为暂存区，通过寄存器“乾坤大挪移”避免 B 内部的冲突。 | < 1300        |
| **61x67**    | 长宽非 2 的幂，地址映射不规则。 很难发生精准的 Set 冲突。    | **16x16 分块**。 只需关注空间局部性，不必担心精准冲突。 **注意**：必须添加边界检查 `(row < N && col < M)` 防止越界。 | < 2000        |

## 4. 关键代码逻辑 (64x64 特化)

为了解决 64x64 下 Cache 只能容纳 4 行导致的冲突，必须使用 **两阶段搬运**：

- **限制 B 的跨度**：写 B 时是按列写入（内存大跨度跳转），必须限制处理块的**高度（针对 B 而言）不超过 4**，防止 B 自身覆盖自身。

- **伪代码逻辑**：

  C

  ```
  // 外层循环处理 8x8 块
  // 阶段一：处理 A 的上半部分 (4行)
  for (k = 0; k < 4; k++) {
      // 1. 读 A 的一行 (8个) -> 存入寄存器 v0-v7 (利用空间局部性，一次读满 Cache Line)
      // 2. 将 v0-v3 (A的左上) -> 写入 B 的左上角 (正确位置)
      // 3. 将 v4-v7 (A的右上) -> 暂存到 B 的右上角 (B 的这个区域目前空闲且不会冲突)
  }
  
  // 阶段二：处理 A 的下半部分 (4行) 并搬运暂存数据
  for (k = 0; k < 4; k++) {
      // 4. 读 A 的下半部分一列 -> 存入 v0-v3
      // 5. 读 B 右上角的暂存数据 -> 存入 v4-v7
      // 6. 将 v0-v3 (A左下) -> 写入 B 的右上角 (覆盖掉刚才的暂存数据)
      // 7. 将 v4-v7 (暂存数据) -> 搬回 B 的左下角 (它们真正的家)
  }
  ```

## 5. 分块策略通用计算公式 (Universal Formula)

在面对任意维度的矩阵 $N \times M$ 与给定的 Cache 参数（总容量 $C$，块大小 $B$）时，可依照以下步骤确定最优分块尺寸 ($W_{block} \times H_{block}$)。

**前置参数**：

- $C$：Cache 总容量 (1024 Bytes)
- $B$：Cache Line 大小 (32 Bytes)
- $ElementSize$：元素大小 (4 Bytes, int)

**第一步：确定分块宽度 ($W_{block}$)**

- **原则**：最大化空间局部性 (Spatial Locality)，用满内存带宽。

- **公式**：

  $$W_{block} = \frac{B}{ElementSize}$$

- **应用**：$32 / 4 = 8$。故宽度定为 **8**。

**第二步：确定分块高度 ($H_{block}$)**

- **原则**：避免冲突不命中 (Conflict Miss)。计算 Cache 能够“同时”容纳多少行矩阵数据。

- **计算矩阵行宽**：$Row_{bytes} = M \times ElementSize$

- **情况 A：规则矩阵 (Power of 2)**

  - **判定**：$Row_{bytes}$ 是 $C$ 的约数（如 32, 64）。

  - **公式**：

    $$H_{block} \le \frac{C}{Row_{bytes}}$$

  - **实例**：

    - 32x32: $1024 / 128 = 8$ $\rightarrow$ 分块 **8x8**。
    - 64x64: $1024 / 256 = 4$ $\rightarrow$ 分块 **8x4** (实际代码中通过逻辑拆分实现)。

- **情况 B：不规则矩阵 (Irregular/Prime)**

  - **判定**：$Row_{bytes}$ 不是 2 的幂。
  - **策略**：映射错位，无精准冲突，优先考虑更大的块以减少循环开销。
  - **建议值**：通常取 **16** 或 **17**。
  - 实际上不是2的幂次也会发生冲突不命中，只是不会全部冲突，所以可以稍微忽视



------

**总结**：

本实验通过 Part A 掌握了 **Cache 的组相联映射机制**与 **LRU 算法**的软件实现；通过 Part B 实践了**分块 (Blocking)** 技术，证明了在直接映射 Cache 下，通过**控制访问步长**和**利用寄存器缓冲**是消除冲突不命中的最有效手段。